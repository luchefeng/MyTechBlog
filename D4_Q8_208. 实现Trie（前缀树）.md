## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=problem-list-v2&envId=2cktkvj)
**[Trie](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

**输入**
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
**输出**
[null, null, true, false, true, null, true]

**解释**
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次
---
## 2. 读完题以后的思路

- 我就反应到它要我实现前缀树这种数据结构，但是这种数据结构我没见过，一把写肯定是写不出来了，就直接找大模型问了
- **这题主要就是能写出前缀树这种数据结构就可以了，其中牵涉到一点小小的语法知识，可以看细节说明部分**
---
## 3. 代码实现

```cpp
class Trie{
private:
	bool isEnd; // 当前节点是否是单词结尾
	Trie* children[26]; // 子节点指针数组(a-z)
public:
	Trie(){
		isEnd = false; // 初始化时不是单词结尾
		memset(children, 0, sizeof(children)); // 所有字节初始化为空
	}

	void insert(string word){
		Trie* node = this; // 从当前根节点开始
		for (char c : word){
			int idx = c - 'a'; // 字母转索引（a=0, b=1, ...）
			if (node->children[idx] == NULL){ // 如果子节点不存在
				node->children[idx] = new Trie(); // 创建新节点
			}
			node = node->children[idx]; // 移动到子节点
		}
		node->isEnd = true; // 标记单词结尾
	}

	bool search(string word){
		Trie* node = this;
		for (char c : word){
			int idx = c - 'a';
			if (node->children[idx] == NULL){
				return false; // 路径中断，单词不存在
			}
			node = node->children[idx];
		}
		return node->isEnd; // 必须是完整单词
	}

	bool startsWith(string prefix){
		Trie* node= this;
		for (char c : prefix){
			int idx = c - 'a';
			if (node->children[idx] == NULL){
				return false; // 路径中断，前缀不存在
			}
			node =  node->children[idx];
		}
		return true; // 前缀存在即可
	}
};
```
---
## 4. 细节说明

### **1. `this` 是关键字吗？**

**答**：是的，`this` 是 C++ 中的关键字。
- **作用**：指向当前对象的指针（即当前类的实例）。
- **使用场景**：
    - 在类的成员函数中，访问当前对象的成员变量或函数。
    - 区分成员变量和局部变量（尤其当同名时）。
- **示例**：
```cpp
void insert(string word) {
        Trie* node = this; // this 指向当前 Trie 对象（通常是根节点）
        // 等效于：Trie* node = &当前对象;
    }
```
### **2. `Trie()` 是类 `Trie` 的一个实例吗？**
**答**：不是。`Trie()` 是类的**构造函数**，用于初始化对象。
- **构造函数**：
    - 与类同名，无返回类型。
    - 在创建对象时自动调用（如 `Trie* obj = new Trie();`）。
- **实例化对象**：
    - 通过 `new Trie()` 或局部变量 `Trie obj;` 创建实例。
- **示例**：
```cpp
Trie* obj = new Trie(); // 调用 Trie() 构造函数，创建实例 obj
```
### **3. `memset` 是什么？怎么用？**
**答**：`memset` 是 C/C++ 的库函数，用于将内存块填充为指定值。
- **头文件**：`#include <cstring>`
- **函数原型**：
```cpp
void* memset(void* ptr, int value, size_t num);
```
    - `ptr`：目标内存地址。   
    - `value`：填充值（通常为 0）。
    - `num`：填充的字节数。
- **用途**：
    - 初始化数组或结构体（如将 `children` 数组的所有指针设为 `nullptr`）。
- **示例**：
```cpp
Trie() {
        isEnd = false;
        memset(children, 0, sizeof(children)); // 将 children 的所有元素初始化为 0（即 nullptr）
    }
```
- **注意事项**：
    - `memset` 按字节填充，适合初始化基本类型（如指针、`char` 数组）。
    - 对非平凡类型（如类对象），建议用循环或默认初始化。
### **代码中关键语句解析**

#### （1）`memset(children, 0, sizeof(children));`
- **作用**：将 `children` 数组的所有元素（26 个指针）设为 `nullptr`。
- **为什么用 0**：在指针上下文中，`0` 等价于 `nullptr`。
#### （2）`Trie* node = this;`
- **含义**：让 `node` 指针指向当前对象（通常是根节点），方便后续遍历。
#### （3）`node = node->children[idx];`
- **作用**：移动到当前字符对应的子节点，实现 Trie 的路径遍历。
### **总结**

| **关键词**  | **类型** | **作用**    | **示例**                        |
| -------- | ------ | --------- | ----------------------------- |
| `this`   | 关键字    | 指向当前对象    | `Trie* node = this;`          |
| `Trie()` | 构造函数   | 初始化对象     | `Trie* obj = new Trie();`     |
| `memset` | 库函数    | 内存填充（初始化） | `memset(arr, 0, sizeof(arr))` |

---
## 5. 复杂度分析

#### **1. 时间复杂度**

|操作|时间复杂度|原因分析|
|---|---|---|
|**插入**|O(m)|需要遍历单词的每个字符（m 为单词长度），每个字符处理是 O(1)（数组索引访问）。|
|**搜索**|O(m)|同样需要逐字符检查路径是否存在。|
|**前缀匹配**|O(m)|只需检查前缀路径，无需验证 `isEnd`。|

- **关键点**：所有操作的时间复杂度**仅与单词长度 `m` 相关**，与 Trie 中存储的单词数量无关。
#### **2. 空间复杂度**

|场景|空间复杂度|原因分析|
|---|---|---|
|**最坏情况**|O(26^m)|如果所有单词无公共前缀，每个字符都需要 26 个子节点（如存储 "a", "b", ..., "z"）。|
|**实际平均**|O(n×m)|n 为单词数量，m 为平均长度。共享前缀的单词会复用节点（如 "app" 和 "apple" 共享 "a-p-p"）。|

- **优化点**：若字符集很大（如 Unicode），可用 `unordered_map` 替代数组，空间复杂度降至 **O(实际使用的字符数)**。

#### **3. 递归调用栈的空间（针对递归实现）**

- **递归深度**：取决于单词长度 `m`，最坏为 `O(m)`。
- **迭代实现**：可优化为 `O(1)` 额外空间（如用循环替代递归）。
---
## 6. 注意事项（可选）

### **前缀树（Trie）——字符串处理的“瑞士军刀”**

#### **1. 什么是前缀树？**

前缀树（**Trie**，发音同"try"）是一种专为**字符串检索**优化的树形数据结构。它的核心思想是：**用公共前缀来高效存储和查询字符串**。举个现实例子：

> 想象一本英文词典，所有单词以字母顺序排列。  
> 查找"apple"时，你会先翻到"A"开头的部分，再找"AP"，最后定位到"APPLE"。  
> **Trie就是这种分层查找的数字化版本**。

#### **2. 为什么需要前缀树？**

- **问题场景**：快速判断一个字符串是否存在（如搜索框自动补全、拼写检查）。
- **传统方法的缺陷**：
    - **哈希表**：虽然查询快，但无法高效支持前缀匹配（如查找以"app"开头的所有单词）。
    - **平衡二叉搜索树**：查询复杂度为O(log n)，而Trie可达到**O(m)**（m为字符串长度）。
#### **3. Trie的结构解剖**

- **节点设计**：
    - 每个节点代表一个**字符**（如'a'-'z'）。
    - 从根节点到某一节点的路径，构成一个**前缀**。
    - 节点额外标记是否为**单词结尾**。