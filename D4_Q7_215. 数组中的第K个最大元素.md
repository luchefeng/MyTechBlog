## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=problem-list-v2&envId=2cktkvj)
给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

**输入:** `[3,2,1,5,6,4],` k = 2
**输出:** 5

**示例 2:**

**输入:** `[3,2,3,1,2,4,5,5,6],` k = 4
**输出:** 4

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
---
## 2. 读完题以后的思路

- 我的思路是先给数组排序，再输出`nums[nums.size() - k]`就可以了。排序的话，可以用二分插入排序。但是二分排序（通常指二分插入排序）的时间复杂度是`O(n²)`，不满足题目要求的`O(n)`。**其实这也就是暴力法的思路了**。咱们知道思路就行，不用管暴力法怎么写代码。
- **快速选择法**：
	- 这是**快速排序的一种变种**。通过改进快速排序算法来得到：在分解的过程当中，我们会对子数组进行划分，如果划分得到的` q` 正好就是我们需要的下标，就直接返回 `a[q]`；否则，如果 `q `比目标下标小，就递归右子区间，否则递归左子区间。**这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率**。
	- 回忆一下**快速排序法：随机选定一个基准值（`pivot`），把比`pivot`小的值换到左边，比它大的值换到右边。如果要查找的值不等于`pivot`，就在左半区间或右半区间递归地去查找。**
- 堆排序法
	- 就理解建堆、调整堆和利用堆排序的过程，会写代码就好了
	- [超好的讲堆的动画演示视频](https://www.bilibili.com/video/BV1HYtseiEQ8?t=11.8)
---
## 3. 代码实现

#### 快速选择

```cpp
// 以下是快速选择法
class Solution{
public:
	int findKthLargest(vector<int> &nums, int k){
		int n = nums.size();
		return quickselect(nums, 0, n - 1, n - k); // 一般快速排序都是从小到大排，所以第k大的元素，就是第n-k小的元素，这里的参数就传的n-k
	}

	int quickselect(vector<int> &nums, int l, int r, int k){
		// 我竟然写这段的时候，把递归的终止条件给漏写了……
		if (l == r) return nums[k];
		int partition = nums[l]; // 随机选一个基准值
		int i = l - 1; // 左指针初始化 为左边界旁边一位
		int j = r + 1; // 右指针初始化 为右边界旁边一位
		// 这样的初始化可以在接下来的“先移动再比较”的过程中，把整个数组的遍历覆盖到，不会漏也不会多，地毯式覆盖
		while (i < j){ // 这里得是<，如果是<=的话，一来是i==j时，有nums[i]和nums[j]相等，此时交换它们也没有意义；二来是如果 nums[i] == pivot（pivot就是“基准”的意思），交换后可能破坏分区结果；三来在某些情况下（如所有元素等于 pivot），i 和 j 会一直停在 i == j 的位置，导致死循环
			do i++; while (nums[i] < partition);
			do j--; while (nums[j] > partition);
			if (i < j) // 如果找到的两个待交换元素的顺序合法，就交换
				swap(nums[i], nums[j]);
		}
		// 递归地对左半区间进行快速选择
		if (k <= j) return quickselect(nums, l, j, k);
		// 递归地对右半区间进行快速选择
		else return quickselect(nums, j + 1, r, k);
	}
};
```

#### 堆排序法

```cpp
class Solution{
public:
	int findKthLargest(vector<int>& nums, int k){
		int heapSize = nums.size();
		buildMaxHeap(nums, heapSize); // 建堆
		// 进行k-1次删除操作
		for (int i = nums.size() - 1; i >= nums.size() - k + 1; i--){
			swap(nums[0], nums[i]); // 把堆顶元素放到末尾
			--heapSize;// 堆元素数目减一
			maxHeapify(nums, 0, heapSize);// 从堆顶 调整堆大小
		}
		return nums[0];
	}

	// 建堆（大根堆）
	void buildMaxHeap(vector<int>& nums, int heapSize){
		for (int i = nums.size() - 1; i >= 0; i--)// 倒着 从第一个非叶子节点开始建堆
			maxHeapify(nums, i, heapSize);
	}

	// 调整堆（下沉）
	void maxHeapify(vector<int>& nums, int i, int heapSize){
		int left = 2 * i + 1; // 节点 i 的左孩子
		int right = 2 * i + 2; // 节点 i 的右孩子
		int largest = i; // 大根堆的顶点
		if (left < heapSize && nums[left] > nums[largest]) largest = left;
		if (right < heapSize && nums[right] > nums[largest]) largest = right;
		if (largest != i){// 下沉(是不断下沉直到符合堆的结构，所以需要递归来不断调整)
			swap(nums[i], nums[largest]);
			maxHeapify(nums, largest, heapSize);
		}
	}
};
```
---
## 4. 细节说明

- ### **关于快速选择的细节说明**
	- 理解快速排序是什么，然后看得懂代码和代码里的注释
	- 要知道为什么左右指针要初始化成那样（那种是先移动，再比较）。如果采用先比较，再移动，理解上直观，但要注意边界的考虑，而且这里`i`和`j`得取等，不然`i == j`这个元素会被遗漏：
```cpp
int i = l, j = r;  // 直接初始化
while (i <= j) {    // 需要 i <= j 确保所有元素被处理
    while (nums[i] < pivot) i++;  // 先比较，再移动
    while (nums[j] > pivot) j--;
    if (i <= j) {                 // 允许 i == j 时的交换（实际无意义但不影响）
        swap(nums[i], nums[j]);
        i++;                      // 移动指针继续
        j--;
    }
}
```

- **递归要注意终止条件啊啊啊**

- ### **关于堆排序的细节说明**
	- 关于调整堆：我们本题采用大根堆，所以如果有不符合堆性质（每棵树自己的根节点值最大），肯定会把这个节点往下放，这就是“下沉”。相应的，小根堆的话就是上浮。
	- 调整堆的方法：是**倒着来（这样可以保证待归位节点自己的左右孩子之下已经是堆的结构了，相对有序了，就更好调整一些）把以每个节点为根 的子树进行堆结构的调整**。对于叶子结点，它没有左右孩子，因此它自己就是一个已经调整好了的堆。所以可以直接从第一个非叶子节点开始建堆。
	- **调整堆是因为传进来一个元素，不知道它的位置应该在哪里，所以才需要调整堆。实际上也就是说，调整堆，就是去调整传进来的元素应该处于的位置**。
	- 用堆来排序：如果想从小往大排，对于大根堆，就是把堆顶元素（最大的）和放到末尾去，也就是和末尾元素进行交换，这样这个最大元素就排好了，然后调整堆，这样子就可以如法炮制获得第二个最大元素。当然，**堆毕竟是一个逻辑结构，它是一种完全二叉树，那么非常连续，它这特殊的性质使得数组是一个很适合用来实现堆的物理存储结构。**
	- **最后回到本题用堆来解决的话**，就是把堆顶的最大元素删除去，删`k-1`次，此时留在堆顶的就是第`k`大的元素了，返回堆顶元素就是结果。（对了，**堆里面的删除操作其实就是交换位置，并且把已经确定位置的元素不再计数，就是不再参与堆的排序了，体现在堆数目减`1`，并不是真的删除了呢。**
---
## 5. 复杂度分析

- ### **关于快速选择的复杂度**
	- 平均时间复杂度：`O(n)`
		数学上可以证明，随机化后的平均时间复杂度为 `O(n)`（我就喜欢已经被证明出来的东西）
	- 空间复杂度：`O(log n)`（平均）或 `O(n)`（最坏）
		因为递归调用栈的原因
- ### **关于堆排序的复杂度**
	- 时间复杂度：`O(nlogn)`
		- 建堆：`O(n)`（数学证明）
		- 删除调整堆操作：`O(nlogn)`
	- 空间复杂度：`O(1)`（因为是原地操作）
		- **递归版是 O(log n)**，但通常可以提一句“如果忽略递归栈，可以认为是 O(1)。
		- 严格O1)还得迭代
---
## 6. 注意事项（可选）

- ### 关于堆：
	-  **堆的本质：是树，但用数组实现**。堆（`Heap`）确实是一种**特殊的完全二叉树(（所有层除最后一层外都是满的，最后一层节点靠左排列）)**，但在实际实现中（尤其是编程时），我们通常用**数组**来存储堆，而非显式地构建树节点。
	- 堆的**物理存储**使用数组，通过下标关系隐式维护树结构（**从下标0开始）：
		- 对于下标为 `i` 的节点：
		    - 父节点：`(i - 1) / 2`（整数除法）。
		    - 左子节点：`2 * i + 1`。
		    - 右子节点：`2 * i + 2`。
	 - 堆的**物理存储**使用数组，通过下标关系隐式维护树结构（**从下标1开始）：
		- 对于下标为 `i` 的节点：
		    - 父节点：`i / 2`（整数除法）。
		    - 左子节点：`2 * i`。
		    - 右子节点：`2 * i + 1`。
	- **为什么用数组而非显式树结构？**
		- **空间高效**：数组无需存储指针（左右子节点、父节点），节省内存。
		- **访问快速**：通过下标计算父子节点位置，时间复杂度为 **O(1)**。
		- **适合完全二叉树**：完全二叉树的连续性完美匹配数组的连续内存。
	-  **堆 vs 二叉搜索树（BST）**

| **特性**    | 堆（Heap）        | 二叉搜索树（BST）    |
| --------- | -------------- | ------------- |
| **结构**    | 完全二叉树          | 任意二叉树         |
| **有序性**   | 仅堆顶有序（父≥子或父≤子） | 左 < 父 < 右     |
| **查找效率**  | O(n)（无序查找）     | O(log n)（平衡时） |
| **插入/删除** | O(log n)       | O(log n)（平衡时） |
| **典型应用**  | 优先队列、TopK问题    | 动态有序数据查询      |

- **堆排序其实是选择排序的一种呢，选择排序分为简单选择排序和堆排序法**