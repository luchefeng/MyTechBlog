## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/sort-list/description/?envType=problem-list-v2&envId=2cktkvj)
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

**输入：**head = [4,2,1,3]
**输出：**[1,2,3,4]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

**输入：**head = [-1,5,3,4,0]
**输出：**[-1,0,3,4,5]

**示例 3：**

**输入：**head = []
**输出：**[]

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
---
## 2. 读完题以后的思路

- 首先注意边界条件：链表为空直接返回，**以及如果链表只有一个节点，也直接返回**
- 归并排序是一个很好的选择，因为它可以高效地处理链表的分割和合并。
- 归并排序解决这道题的步骤：
	1. **分割链表**：使用快慢指针找到链表的中点，将链表分成两部分。
	2. **递归排序**：对分割后的两个子链表分别进行排序。
	3. **合并链表**：将两个已排序的子链表合并成一个有序链表。
---
## 3. 代码实现

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
	    // 递归终止条件：空链表或仅有一个节点的链表，直接返回
	    if (head == NULL || head->next == NULL) return head;
	    // 第一步，快慢指针从中间分割链表
	    ListNode* slow = head;
	    ListNode* fast = head;
	    while (fast->next && fast->next->next){
		    slow = slow->next;
		    fast = fast->next->next;
	    }
	    // 链表被分割为两部分
	    ListNode* mid = slow->next;
	    slow->next = NULL;
	    // 第二步，对左右子链表继续递归地分割
	    ListNode* left = sortList(head);
	    ListNode* right = sortList(mid);
	    // 第三步，合并子链表
	    return merge(left, right);
    }
private:
	ListNode* merge(ListNode* L1, ListNode* L2){
		ListNode dummy(0);
		ListNode* tail = &dummy;

		while (L1 && L2){
			if (L1->val < L2->val){
				tail->next = L1;
				L1 = L1->next; // L1指针移动到下一位
			} else{
				tail->next = L2;
				L2 = L2->next; // L2指针移动到下一位
			}
			tail = tail->next;
		}
		if (L1){
			tail->next = L1;
		} else {
			tail->next = L2;
		}
		return dummy.next;
	}
};
```
---
## 4. 细节说明

- **在`merge()`函数里，把两个链表中小的值放到哑结点后面之后，要记得更新`L1` 和`L2`指针往后移动一位，不然会陷入死循环！**
- 快慢指针那里，我写笔记的时候，才发现快指针走的步数写成和慢指针一样了（掩面）
- **边界条件（也就是递归终止条件）要注意，不仅考虑空链表，只有一个节点的链表也要考虑**。我当时只考虑了空链表，就报错了。

#### **关于哑结点 `dummy` 的问题说明**

##### **1. 为什么 `dummy` 要初始化一个值？**
- `ListNode dummy(0)` 创建了一个**栈上的局部变量**，它的生命周期仅限于 `merge` 函数内。
- 这个 `dummy` 的作用是**作为合并后链表的头结点的前驱**，方便统一处理链表合并逻辑。
- 它的 `val` 可以是任意值（这里用 `0`），因为最终返回的是 `dummy.next`，`dummy` 本身不会被使用。
##### **2. 能不能只用指针，不要 `dummy` 的值？**
- **可以，但需要动态分配内存**（例如 `ListNode* dummy = new ListNode(0);`），但这样会增加内存管理的负担（需要手动 `delete`）。
- **栈上的 `dummy` 更高效**：
    - 不需要 `new/delete`，避免内存泄漏风险。
    - 作用域结束后自动销毁，无需手动释放。
##### **3. 为什么 `ListNode dummy(0)` 这种写法看起来稀奇？**
- 这是 C++ 的**直接初始化（Direct Initialization）**语法，等价于 `ListNode dummy = ListNode(0);`。
- 在 C++11 之后，还可以用 `ListNode dummy{0};`（列表初始化）。
- 这种写法比 `new` 更推荐，因为它是栈上对象，更安全高效。
---
## 5. 复杂度分析

- **时间复杂度是 O(n log n)**
	- - 分割：每次递归减半，`O(log⁡n)` 层。
	- 合并：每层总合并时间 `O(n)`。
	
- **空间复杂度： O(log n)**
	- 因为递归栈空间

---
## 6. 注意事项（可选）

- **我这个版本是“自顶向下的归并排序”（递归）**，复杂度如上所述。**如果要实现题目的进阶要求，也就是时间复杂度是 `O(n log n)`，空间复杂度是 `O(1)`，那么就需要“自底向上的归并排序”**，我略微看了一下，基本上是迭代。我没学这种办法。

- **归并排序（Merge Sort）** 是一种 **分治（Divide and Conquer）** 算法，它的核心思想是：
	1. **分割（Divide）**：将链表不断二分，直到每个子链表只剩一个节点（自然有序）。
	2. **合并（Conquer）**：从最底层开始，逐步合并两个有序链表，最终得到完整的有序链表。

- **为什么 `ListNode dummy(0)` 是栈上的局部变量？**在 C++ 中，变量的存储位置由它的**声明方式**决定：

| 存储区域         | 示例代码                                 | 生命周期         | 特点           |
| ------------ | ------------------------------------ | ------------ | ------------ |
| **栈（Stack）** | `ListNode dummy(0);`                 | 所在函数结束时销毁    | 自动管理，高效      |
| **堆（Heap）**  | `ListNode* dummy = new ListNode(0);` | 需手动 `delete` | 动态分配，可能内存泄漏  |
| **全局变量**     | `ListNode dummy(0);`（在函数外）           | 程序结束时销毁      | 占用全局内存，不推荐滥用 |
 - 我们复习一下几种排序的原理、实现以及复杂度、稳定性分析，见我写的[排序总结（九大排序）](obsidian://open?vault=Technical_Eight_Strands&file=LeecodeHot100%2FD12_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%EF%BC%89)