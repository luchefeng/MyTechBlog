## 1. 题目描述及链接
[力扣题目链接](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=problem-list-v2&envId=2cktkvj)
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

**输入：**head = `[1,2,2,1]`
**输出：**true

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

**输入：**head =` [1,2]`
**输出：**false

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

---
## 2. 读完题以后的思路

- 用双指针，一个指针指向头部，一个指向尾部，两头向中间遍历，如果在遍历到左指针大于右指针，左右指针都还相等的话，就说明是回文链表。**但是这样有一个问题难以解决：链表的难点在于它是单向的，不能直接从尾部向前遍历**。因此，我们需要找到一种方法来实现类似的双指针遍历。

- **快慢指针法**：
1. **找到链表的中间节点**：使用快慢指针法。快指针每次移动两步，慢指针每次移动一步。当快指针到达链表末尾时，慢指针正好在中间。
    
2. **反转后半部分链表**：从慢指针的位置开始反转后半部分链表。
    
3. **比较前后两部分链表**：将前半部分和反转后的后半部分逐一比较，如果所有节点值都相同，则链表是回文的。
---
## 3. 代码实现

```cpp
class Solution {

public:
    bool isPalindrome(ListNode* head) {
        // 边界考虑：空链表or只有一个节点的链表，一定是回文链表
        if (head == NULL || head->next == NULL){
            return true;
        }
        // 第一步，快慢指针，找中间节点
        // 奇数长度，中间节点在正中；偶数长度，中间节点在前半段最后一个节点处
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != NULL && fast->next->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
        }
        // 第二步，反转后半部分链表
        ListNode* secondHalf = reverseList(slow->next);
        ListNode* firstHalf = head;
        // 第三步，比较前后两部分链表
        while (secondHalf != NULL){//  后半链表的长度小于（奇数链表）或等于（偶数链表）前半链表的长度，所以后半链表走完，就比较完了

            if (firstHalf->val != secondHalf->val){
                return false;
            }
            firstHalf = firstHalf->next;
            secondHalf = secondHalf->next;
        }
        return true;
    }

private:
    ListNode* reverseList(ListNode* head){
        ListNode* prev = NULL;
        ListNode* curr = head;
        while (curr != NULL){
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
};
```
---
## 4. 细节说明

- 要考虑空回文链表的情况，还有要考虑只有一个节点的链表的情况，它们都是回文链表，可以直接返回`true`

- 快慢指针法中，选用快指针两步，慢指针一步，可以保证遍历链表时不会跳元素，而且快指针速度正好是慢指针两倍，这样快指针停下来时，慢指针会正好在链表中部或者左右偏离一点点，位置合适

- 这题如果是奇数长度的链表，那快指针走到最后一个节点时，慢指针正好走到链表中部，这时后半部分链表的长度比前半部分小`1`；而如果是偶数长度的链表，快指针走到倒数第二个节点时，慢指针走到前半部分链表的最后一个节点处，此时后半部分链表的长度和前半部分想等。所以在比较前后两部分链表节点值是否相等时，只要`while`里后半部分不为空就继续遍历就好了

- 反转链表那里要自己写一个`private`函数，不写这个`private`的话，默认就是`private`。这个函数要注意的是，**不是交换节点**，而是让每个节点的 `next` 指向前一个节点，`prev` 始终指向已反转部分的头节点。
---
## 5. 复杂度分析

- #### 时间复杂度：`O(n)`
##### 1. **快慢指针找链表中点**

- **时间复杂度**：O(n)  
    快指针每次走2步，慢指针每次走1步，直到快指针到达链表末尾。由于遍历了整个链表，所以时间复杂度是线性的。
    
##### 2. **反转后半部分链表**

- **时间复杂度**：O(n/2) → O(n)  
    反转后半部分链表需要遍历一半的节点，但大O表示法忽略常数，所以仍然是O(n)。
    
- **操作本质**：反转链表就是通过调整指针方向（`curr->next = prev`）来完成，没有额外的存储开销。
##### 3. **比较前后两部分链表**

- **时间复杂度**：O(n/2) → O(n)  
    需要逐个比较前半部分和反转后的后半部分节点，最多比较n/2次。
##### **总时间复杂度**

- **O(n) + O(n) + O(n) = O(n)**  
    虽然进行了三次线性操作，但总时间复杂度仍然是O(n)。
##### **空间复杂度**

- **O(1)**  
    只用了常数级别的额外空间（几个指针变量）。
---
## 6. 注意事项（可选）

- 这题不能用`head.val`和`head.next`来表达，只能用`head->next`和`head->val`
	- 在 `C++` 中，**`head` 是指针（`ListNode*`）**，访问指针的成员必须用 `->`，**如果 `head` 是对象（非指针）**，才能用 `.`，而不能用`->`。
- 本题和昨天的“链表相交”不同，昨天那个实际上是内存共享问题，所以注意比较的是指针相同否；而今天的是判断回文，因此实际上比较的是节点的值