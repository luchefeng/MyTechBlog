## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=problem-list-v2&envId=2cktkvj)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

**输入：**`nums = [100,4,200,1,3,2]
**输出：**4
**解释：**最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

**示例 2：**

**输入：**`nums = [0,3,7,2,5,8,4,6,0,1]
**输出：**9

**示例 3：**

**输入：**`nums = [1,0,1,2]
**输出：**3

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
---
## 2. 读完题以后的思路

- 我的原始思路会是想先排序，但是排序以后怎么知道从谁开始能得到最长的连续序列呢？还有连续序列到谁是个头？这怎么判断？
- 看完解析以后，我明白了思路，是这样的：
- **不知道谁开始能得到最长的连续序列，所以每一个元素都有可能，因此每个元素都应该考虑一下。至于看一个元素 num 能不能是一段连续序列的起点，就看它有没有前一个数 num - 1。如果不是起点就跳过，是起点就开始记录长度。**
- **考虑到去重的影响和查找的方便，本题选择哈希集合 `unordered_set`作为数据结构**
---
## 3. 代码实现
#### 范围 for 循环的写法
```cpp
#include <vector>
#include <unordered_set>
#include <algorithm> // max
class Solution{
public:
	int longestConsecutive(vector<int>& nums) {
		int longest = 0;
		unordered_set<int> numSet;
		// 将数组元素存入哈希集合中，自动去重
		for (int num : nums){
			numSet.insert(num);
		}
		// 从集合中，找可以成为起点的元素
		for (int num : numSet){
			// 如果 num - 1 不在集合里，那 num 就可以作为起点
			if (numSet.find(num - 1) == numSet.end()){
				int currentNum = num; // 当前元素
				int curLen = 1; // 本次最大长度，目前已经有起点这一个了

				while (numSet.find(currentNum + 1) != numSet.end()){
					currentNum += 1; // 移向下一个元素
					curLen += 1; // 当前连续序列长度 加一
				}
				longest = max(longest, curLen); // 更新最大长度
			}
		}
		return longest;
	}
};
```

#### 哈希集合那里的循环 用迭代器 的写法（数组元素入集合时可以就用普通for 循环）
```cpp
class Solution{
public:
	int longestConsecutive(vector<int>& nums) {
		int longest = 0;
		unordered_set<int> numSet;
		// 可以使用普通循环，我这里改给你看
		for (int i = 0； i < nums.size(); i++){
			numSet.insert(num[i]);
		}
		// 从集合中，找可以成为起点的元素
		for (auto it = numSet.begin(); it != numSet.end(); it++){
			int num = *it; // 这里很重要，这里不是指针，是迭代器！
			
			if (numSet.find(num - 1) == numSet.end()){
				int currentNum = num;
				int curLen = 1;

				while (numSet.find(currentNum + 1) != numSet.end()){
					currentNum += 1;
					curLen += 1; 
				}
				longest = max(longest, curLen); 
		}
		return longest;
	}
};
```
---
## 4. 细节说明

- 力扣是核心代码模式，**要能知道这题用到的头文件（见代码框里面哈）**

- **把`longest`初始化为`0`，其实就相当于已经考虑给定数组为空的情况了，就不需要单独来个条件判断了哈**

- **注意，由于每一个能作为起点的元素都要去算算看它的最大长度，所以需要一个局部的变量来记录每一次的结果，还需要一个全局变量来更新所有结果中的最长结果。**

- **还有的话，关于循环，对于这些 STL 容器，可以直接用范围 for 循环，它们的底层就是基于迭代器的。也可以直接使用迭代器的写法来循环，但是会容易出错一些，因为我不熟悉嘛。**

- **针对上条，因为哈希集合不支持通过索引 `[i]` 来访问元素，它只能通过迭代器或`find()`方法来访问。所以我写了一个普通 for ，就报错了。**

- 不过嘞，也知道了一个小点：**哈希集合的长度可以用 `.size()` 得到。**还有，哈希集合的话，是用 `insert()`, `find()` 和`end()`的哈
---
## 5. 复杂度分析

#### 时间复杂度：`O(n)`
- 每个不重复元素放进集合是`O(n)`，之后在集合里找起点，要么是起点，要么跳过，总的也是`O(n)`，加起来就还是 `O(n)`
#### 空间复杂度：`O(n)`
- 使用了哈希集合，不重复的话，就会把每个元素存一次

---
## 6. 注意事项（可选）
#### 支持范围for循环的容器：

- 所有STL容器： `vector`, `array`, `deque`, `list`, `forward_list`
- 关联容器：`set`, `multiset`, `map`, `multimap`, `unordered_set`, `unordered_map`等
- 原生数组
- 任何实现了 `begin()` 和 `end()` 方法的自定义容器

#### 哈希集合 的 自动去重
- `std::unordered_set` 的一个重要特性就是**自动去重**。当您尝试向 `unordered_set` 中插入一个已经存在的元素时，插入操作会失败（`insert` 方法会返回一个 pair，其中的第二个值 `bool` 为 `false`，表示插入未发生）。 