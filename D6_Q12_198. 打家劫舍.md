## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/house-robber/description/?envType=problem-list-v2&envId=2cktkvj)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

**输入：**[1,2,3,1]
**输出：**4
**解释：**偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**

**输入：**[2,7,9,3,1]
**输出：**12
**解释：**偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`
---
## 2. 读完题以后的思路

- 打家劫舍入门题，打开力扣看见之前写的代码，才想起来是**动态规划**
- 本题的棘手之处在于，除了一条规则（相邻的不能偷）以外，怎么偷都可以，那么选择的偷不偷对自由度挺大的，有点不知道怎么下手。那么，**当前房间偷不偷，其实和前一个房间以及前两个房间偷不偷有一定关系。** 接下来用动规五部曲分析这道题目：
	- 第一步，`dp`数组含义：
		- **考虑下标`i`（包含），能偷的最大钱币的数目为`dp[i]`**（再翻译一下，就是考虑下标`i`及其之前的房间后，能偷的最大钱币数目。还有一种说法我也觉得好理解一些：偷到第`i`个房子时的最大价值）。那么**最终要求的结果就是`dp[nums.size() - 1]`**
			- **注意，`dp[nums.size() - 1]`是说考虑了最后一个房间，不一定非要把最后一个房间偷了。仅仅是考虑而已。**
	- 第二步，递推公式
		- `dp[i]`的状态实际上就是偷`i`还是不偷`i`，如果：
			- 偷`i`：`dp[i] = nums[i](确定要偷i了，那这个房间的钱就加进去) + dp[i-2]（确定要偷i了，那i-1这个房间铁定不能偷，那么就只能去考虑i-2及之前的房间能偷的最大钱币了）`
			- 不偷`i`：`dp[i] = dp[i-1]（确定不偷i了，那i-1及之前的房间都可以被考虑了`
			- 最后取两种情况的最大值，就是`dp[i]`的状态：`dp[i] = max(dp[i-2] + nums[i], dp[i-1]);`
	- 第三步，初始化
		- 由递推公式知，最后牵扯到的最初的状态就是`dp[0]`和`dp[1]`。
			- 对于`dp[0]`，指定得偷，因为只有这一个房间可以偷，所以`dp[0] = nums[0];`
			- 对于`dp[1]`，它可以考虑房间`1`，但它未必要偷。事实上，它有两个房间可以考虑，由于规则所限，它肯定只能偷其中一个房间，因此`dp[1] = max(nums[0], nums[1]);`
			- **初始化还有很重要的一点就是，还要考虑除了必须要特殊初始化的那几个状态，对于非那几个状态的情况也要注意初始化，只不过有些是怎么初始化都不影响，因为会被覆盖，就像这个题。** 所以，这个题的非`0`和非`1`下标的初始化，就初始化成`0`就可以了。
	- 第四步，遍历顺序
		- 为了用到前面两种状态，需要从左往右遍历。计数器`i`直接从`2`开始就可以了，因为`0`和`1`已经初始化了
	- 第五步，打印dp`数组
		- 要是状态不对，打印出来看看咋回事
---
## 3. 代码实现

```cpp
class Solution {

public:

    int rob(vector<int>& nums) {
	    // 为初始化准备的边界考虑：只有0个或1个房间
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
		// dp 数组及其初始化
		vector<int> dp(nums.size(),0);
		dp[0] = nums[0];
		dp[1] = max(nums[0], nums[1]);
		// 遍历顺序及递推公式
		for (int i = 2; i < nums.size(); i++){
			dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
		}
		return dp[nums.size() - 1];
    }
};
```
---
## 4. 细节说明

- 每次都会忘记考虑边界的说……这个题吧，要想初始化`dp[0]`（其实`dp[1]`也是按`dp[0]`的状态推的），首先得有`dp[0]`。得先来个边界判断（掩面）。
---
## 5. 复杂度分析

#### **1. 时间复杂度：O(N)**
- **初始化 `dp` 数组**：前两个元素直接赋值 → O(1)。
- **主循环**：从 `i = 2` 遍历到 `i = N-1`，每次计算 `dp[i]` 仅需常数时间（比较和加法）→ O(N)。
- **总时间**：O(N)。
#### **2. 空间复杂度：O(N)**
- **`dp` 数组**：存储每个位置的最大金额 → O(N)
---
## 6. 注意事项（可选）
