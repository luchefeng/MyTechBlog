## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/maximal-square/description/?envType=problem-list-v2&envId=2cktkvj)

[Tag:动态规划]

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

**输入：**matrix =` [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`
**输出：**4

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

**输入：**matrix = `[["0","1"],["1","0"]]`
**输出：**1

**示例 3：**

**输入：**matrix = `[["0"]]`
**输出：**0

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`
---
## 2. 读完题以后的思路

- 我的思路是，肯定要用到图和图的搜索。相当于去图里面找岛屿。但是我卡在三个点：第一，如果这个图里有多个岛屿，那怎么比较面积？第二，如果搜出来，岛屿不是正方形，我要怎么能选出最短的边然后平方返回面积？第三，我忘了深搜或者广搜怎么写了……**结果一问，这题用动规*

- `DeepSeek`说：
	- 岛屿问题（如 `LC 200`）通常计算的是连通区域面积，但本题要求的是**正方形**，所以不能直接用 DFS/BFS 计算面积。
	- 本题不适用 DFS/BFS，因为正方形需要**边长相等**，而 DFS/BFS 难以直接计算最大正方形边长。
---
## 3. 代码实现

- 以下是我的版本，动规的思路也写在里面了
```cpp
// 以下是我的版本
class Solution {

public:

    int maximalSquare(vector<vector<char>>& matrix) {
        // 边界考虑：空矩阵直接返回
        if (matrix.empty() || matrix[0].empty()) return 0;
        // 第一步，dp数组含义：右下角全是1的正方形的最大边长（定义为右下角，我觉得是为了遍历顺序的方便，符合一般从左到右，从上到下的认知）
        // 第二步，递推公式：dp = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1
        // 第三步，初始化：需要初始化dp数组的第一行和第一列，如果是1，dp也是1；如果是0，dp也是0.实际上就和原矩阵的第一行第一列一样了
        // 第四步，遍历顺序：因为选取dp为右下角，所以遍历顺序是从左往右，从上到下
        // 第五步，打印dp数组

        // dp数组
        int row = matrix.size();
        int column = matrix[0].size();
        vector<vector<int>> dp(row, vector<int>(column,0));
        int max_size = 0;
        // dp数组的初始化，非第一行第一列直接初始化为0就可以，反正会被覆盖
        for (int i = 0; i < row; i++){
            dp[i][0] = matrix[i][0] - '0';
            max_size = max(max_size, dp[i][0]);
        }
        for (int j = 0; j < column; j++){
            dp[0][j] = matrix[0][j] - '0';
            max_size = max(max_size, dp[0][j]);
        }

        // 遍历顺序及递推公式
        for (int i = 1; i < row; i++){
            for (int j = 1; j < column; j++){
                if (matrix[i][j] == '1'){
                    dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1;
                    max_size = max(max_size, dp[i][j]);
                }
            }
        }
        // 打印dp
        /*
        for (int i = 0; i < row; i++){
            for (int j = 0; j < column; j++){
                cout << dp[i][j];
            }
        }*/
        return max_size*max_size;
    }
};
```

- 我再给出优化版本，主要就是`DeepSeek`在我的基础上把初始化优化了一下，我觉得挺好的，就是思路没有我那种好理解了
- #### 优化点
- 初始化时可以统一处理所有边界情况（第一行和第一列），不需要单独初始化。因为：
	- `dp` 数组已经初始化为全0
	- 当 `i==0` 或 `j==0` 时，最大正方形边长只能是0或1（取决于当前格子是否为'1'）

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0;
        int row = matrix.size();
        int column = matrix[0].size();
        vector<vector<int>> dp(row, vector<int>(column, 0));
        int max_size = 0;
        // 统一处理所有边界情况
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1;
                    }
                    max_size = max(max_size, dp[i][j]);
                }
            }
        }
        return max_size * max_size;
    }
};
```

---
## 4. 细节说明

- 我的代码当时出了一些问题：
- ### **问题分析**

1. **初始化错误**：
    
    - 你直接将 `dp[i][0] = matrix[i][0]` 和 `dp[0][j] = matrix[0][j]`，但 `matrix` 存储的是字符 `'0'` 和 `'1'`，而 `dp` 是 `int` 类型，直接赋值会导致 `dp` 存储的是字符的 ASCII 码（`'0'` 的 ASCII 码是 48，`'1'` 是 49），而不是 `0` 和 `1`。
        
    - 应该改为 `dp[i][0] = matrix[i][0] - '0'` 或 `dp[i][0] = (matrix[i][0] == '1') ? 1 : 0`。
        
2. **递推公式的条件缺失**：
    
    - 只有在 `matrix[i][j] == '1'` 时才需要更新 `dp[i][j]`，否则 `dp[i][j]` 应该是 `0`。
        
    - 你直接对所有位置计算 `dp[i][j]`，没有检查 `matrix[i][j]` 是否为 `'1'`。
        
3. **最大边长的记录错误**：
    
    - 你直接返回 `dp[row-1][column-1] * dp[row-1][column-1]`，但最大正方形可能出现在矩阵的任何位置，而不仅仅是右下角。
        
    - 应该在遍历过程中记录全局最大边长 `max_side`，最后返回 `max_side * max_side`。
### 关键错误

在递推部分的判断条件：
```cpp
if (dp[i][j] == '1')  // 错误！这里应该是检查 matrix[i][j]
```

- `dp[i][j]` 是整型，而 `'1'` 是字符（ASCII码49），这里应该检查原矩阵 `matrix[i][j]` 是否为 `'1'`。

---
## 5. 复杂度分析

- 时间复杂度：`O(mn)`（遍历整个矩阵一次）
    
- 空间复杂度：`O(mn)`（dp数组）
---
## 6. 注意事项（可选）

以下是我完成这个题猜的坑：
- 注意考虑边界，即矩阵行或列为空时的情况
- 数据类型混淆
	- `matrix` 是 `char` 类型（存储 `'0'` 和 `'1'`），而 `dp` 是 `int` 类型，赋值会导致存储 ASCII 码（`'0'`=48，`'1'`=49）。
	- 解决办法：显式转换为数字：`dp[i][0] = matrix[i][0] - '0';`
-  **递推条件遗漏**
	- 想都没想就把递推公式放在遍历顺序里面去了。未检查 `matrix[i][j]` 就直接计算 `dp[i][j]`，而实际上，只有当前格子为 `'1'` 时才需要更新 `dp`；而且我改了一次后，还用的`if (dp[i][j] == '1')`……应该是`matrix[i][j] == '1'`才对
	- 解决办法：添加条件判断：
	```cpp
	if (matrix[i][j] == '1') {  // 检查原矩阵，而非 dp 数组
    dp[i][j] = min(...) + 1;
}
```

-  **最大边长记录错误**
	- 直接返回 `dp[row-1][column-1]` 的平方。但实际上，最大正方形可能出现在矩阵任意位置，不一定是右下角。
	- 解决办法：在遍历时动态更新全局最大值。`max_size = max(max_size, dp[i][j]);`。
	- **注意这个`max_size`在`dp`数组进行初始化时，也要跟着更新的！**

- 初始化遗漏
	- 我光初始化`dp`的第一行和第一列去了，忘了给人家非首行首列的元素初始化了，所以第一次跑出来结果很大很随机（掩面）