## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/palindromic-substrings/description/?envType=problem-list-v2&envId=2cktkvj)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

**示例 1：**

**输入：**s = "abc"
**输出：**3
**解释：**三个回文子串: "a", "b", "c"

**示例 2：**

**输入：**s = "aaa"
**输出：**6
**解释：**6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成
---
## 2. 读完题以后的思路
- 我感觉像字符串的问题，用双指针一般都可以做到。但我不太清楚要怎么做
- 本题我第一次接触的时候，是在动规学习的时候。这题也可以用动规来解决。
### 动态规划思路
- 第一步，`dp`数组下标及含义（这题这一步就不是很好想，和常规的动规数组含义其实差别有点大的）
	- **`dp[i][j]`：以下标`i`和`j`（`i`和`j`)包含为范围的字串是否是回文串**。那么就是个**布尔类型**的数组。其中`j >= i`。
- 第二步，递推公式
	- 主要就是考虑如果`i`和`j`之间的字串是回文串，那么再比较`s[i]`和`s[j]`是否相等，如果相等，那`dp[i][j]`就也是回文串。但是在比较`s[i]`和`s[j]`是否相等之后，**要分三种情况讨论：`j == i`，也就是`a`这样；`j`和`i`相差`1`，也就是`aa`这样；最后就是`j-i > 1`，这时就是考虑`dp[i+1][j-1]`了**
- 第三步，初始化
	- 把`dp[i][j]`全初始化为`false`就可以了，因为一开始也不知道有没有回文串
- 第四步，遍历顺序 

|              | dp[i][j] |
| ------------ | -------- |
| dp[i+1][j-1] |          |

由图可见的推导方向知，遍历顺序应该是从左往右，**从下到上**的

- 第五步，打印`dp`数组

### 双指针思路
- 从中心出发向两边扩展，看是不是对称，以找 回文串
- **遍历中心点的时候，注意中心点有两种情况**。一个元素可以作为中心点，两个元素也可以作为中心点。
- 三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。所以不用单独考虑。
---
## 3. 代码实现

### 动规
```cpp
class Solution{
public:
	int countSubstrings(string s) {
		int count = 0;
		int n = s.size();
		// dp数组及其初始化
		vector<vector<bool>> dp(n+1, vector<bool>(n+1, false));
		// 遍历顺序及递推公式
		for (int i = n - 1; i >= 0; i--){
			for (int j = i; j < n; j++){
				if (s[i] == s[j]){
					// 情况一：i j 相等
					if (j == i){
						dp[i][j] = true;
						count++;
					// 情况二：i j 相差1
					}else if (j - i == 1){
						dp[i][j] = true;
						count++;
					// 情况三：i j 相差大于1
					} else if (dp[i+1][j-1] == true){
						dp[i][j] = true;
						count++;
					}
				}
			}
		}
		return count;
	}
};
```

### 双指针法
```cpp
class Solution{
public:
    int countSubstrings(string s){
	    int result = 0;
	    for (int i = 0; i < s.size(); i++){
		    result += extend(s, i, i, s.size()); // 中心点为 1 个
		    result += extend(s, i, i+1, s.size()); // 中心点为 2 个
	    }
	 return result;
    }

	int extend(const string& s, int i, int j, int n){
		int res = 0;
		while (i >= 0 && j < n && s[i] == s[j]){
			i--;
			j++;
			res++;
		}
	return res;
	}
};
```
---
## 4. 细节说明

- **我每次倒着写循环的时候，我都一个顺手把计数器写成了 i++，别个是 i-- 好嘛（掩面）**
- **双指针法的话，注意中心点个数要分两种情况考虑哈**
---
## 5. 复杂度分析
### 动规
- 时间复杂度：`O(n^2)`
	- 因为双重循环，每个数操作（比较）一次
- 空间复杂度：`O(n^2)`
	- 因为`dp`数组是二维数组
### 双指针
- 时间复杂度：`O(n^2)`
	- 因为双重循环，每个数操作（比较）一次
- 空间复杂度：`O(1)`
	- 因为只用了几个指针
---
## 6. 注意事项（可选）
