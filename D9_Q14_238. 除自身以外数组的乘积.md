## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=problem-list-v2&envId=2cktkvj)
给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

**输入:** nums = `[1,2,3,4]`
**输出:** `[24,12,8,6]`

**示例 2:**

**输入:** nums = [-1,1,0,-3,3]
**输出:** [0,0,9,0,0]

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在  **32 位** 整数范围内
---
## 2. 读完题以后的思路

- 我乍一看还觉得像单调栈呢，想了想单调栈里也没这个题。我就去看解法了。
- 原来这题是使用**前缀积和后缀积**啊，超级酷，思路是这样的：
	- 从左到右计算`i`之前的元素的乘积（前缀积），记录到结果数组的对应下标里，也就是`answer[i]`里；
	- 再从右往左计算`i`之后的元素的乘积（后缀积），将其与`answer[i]`里已有的前缀积相乘，就能得到题目想要的结果
	- 注意那个结果数组`answer`的大小和给定数组相同哈，初始化为`1`
---
## 3. 代码实现

``` cpp
class Solution{
public:
	vector<int> productExceptSelf(vector<int>& nums) {
		int n = nums.size();
		vector<int> answer(n, 1);  // 定义一个和给定数组一样大小的结果数组，初始化为1

		int prefix = 1;
		// 计算前缀积
		for (int i = 0; i < n; i++){
			answer[i] = prefix; // 先记录当前前缀积
			prefix *= nums[i]; // 再继续更新前缀积
		}

		int suffix = 1;
		// 计算后缀积
		for (int i = n - 1; i >= 0; i--){
			answer[i] *= suffix; // 先记录后缀积与前缀积的相乘情况
			suffix *= nums[i]; // 再继续更新后缀积
		}
		return answer;
	}
};
```
---
## 4. 细节说明

- **计算前缀积时**， 要先记录当前前缀积，再继续更新前缀积
- **计算后缀积时**， 要先记录后缀积与前缀积的相乘情况，再继续更新后缀积
---
## 5. 复杂度分析

- 时间复杂度
	- 遍历整个数组两次，时间复杂度`O(n)`
- 空间复杂度
	- 使用了和原数组一样大小的数组，空间复杂度`O(n)`
---
## 6. 注意事项（可选）

### 关于题目的一些考虑

- #### 1. **为什么要** **避免除法**：
    
    - 如果允许除法，我们可以先计算整个数组的乘积 `total_product`，然后 `answer[i] = total_product / nums[i]`。
	    - 原因：**直观理解**
			- `total_product = nums[0] × nums[1] × ... × nums[n-1]`
			- `answer[i]` 是 **除了 `nums[i]` 之外所有数的乘积**，所以：
			![[Pasted image 20250808213333.png]]
    - 但题目明确要求 **不能使用除法**，因为如果 `nums[i] = 0`，这种方法会失效。

- #### 2. **为什么要**有 ****前缀/后缀积不溢出的保证****：

	- 如果 `nums` 里有很多大数，它们的乘积可能会超过 `INT_MAX`，导致溢出（变成负数或错误值）。题目保证 **前缀积和后缀积都不会溢出**，所以我们可以放心计算。
	
	- - **确保算法的正确性**：我们的解法需要计算前缀积和后缀积，如果它们可能溢出，就需要用 `long long` 或取模等方式处理，但题目简化了这个问题。
	
	- 总之就是：让解法可以直接用 `int` 计算，无需处理溢出。
