## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/invert-binary-tree/description/?envType=problem-list-v2&envId=2cktkvj)
给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

**输入：**root = [4,2,7,1,3,6,9]
**输出：**[4,7,2,9,6,3,1]

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

**输入：**root = [2,1,3]
**输出：**[2,3,1]

**示例 3：**

**输入：**root = []
**输出：**[]

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`
---
## 2. 读完题以后的思路

- 我没有思路（掩面），但我关注到用例里面，如果传入的是空树，那就返回空树（**我没想到这个也是递归的终止条件**）。这个也许可以拿来通过一个测试用例，但实际上可能因为不完整，编译不通过。
- 看卡哥视频去了：
	- 这题可以有三种解法：递归，非递归，层序遍历
	- 递归解法（也是一种`DFS`）：
		- 推荐前序遍历和后序遍历，中序遍历有点绕。
	- 非递归解法之：
		- 层序遍历（`BFS`）（我看了讲解视频，把代码放在代码实现里了）
		- 迭代法（`DFS`）
---
## 3. 代码实现

```cpp
// 递归版本——前序遍历
class Solution {

public:

    TreeNode* invertTree(TreeNode* root) {
        // 终止条件
        if (root == NULL) return root;
        // 前序遍历的交换处理逻辑
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        // 递归遍历左右子树
        invertTree(root->left);
        invertTree(root->right);
  
        return root;
    }
};
```

```cpp
// 递归版本——后序遍历
class Solution {

public:

    TreeNode* invertTree(TreeNode* root) {
        // 终止条件
        if (root == NULL) return root;
        // 递归遍历左右子树
        invertTree(root->left);
        invertTree(root->right);

        // 后序遍历的交换处理逻辑
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        
        return root;
    }
};
```

```cpp
// 递归版本——中序遍历（会有点绕，不推荐）
class Solution {

public:

    TreeNode* invertTree(TreeNode* root) {
        // 终止条件
        if (root == NULL) return root;
        // 递归遍历左子树
        invertTree(root->left);
        // 中序遍历的交换处理逻辑
        //TreeNode* temp = root->left;
        //root->left = root->right;
        //root->right = temp;
        swap(root->left, root->right);
        // 递归遍历原本的右子树
        invertTree(root->left);
        
        return root;
    }
};
```

```cpp
// 层序遍历（BFS）

class Solution {

public:

    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL)
            que.push(root);
        while (!que.empty()){
            int size = que.size();
            for (int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // 节点处理
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```
---
## 4. 细节说明

- 这题交换左右孩子，实际上交换的是左右孩子的指针哦，不是数值
- 注意递归有终止条件哦
- “中”的处理，可以直接写经典交换代码，也可以使用`swap()`，本质是一样的
- 中序遍历有点绕，是因为中序遍历的话，先遍历左子树到底，然后“中”的处理，使左子树翻转到了右子树，此时因为中序遍历，所以开始处理“右”，而此时的右子树就是原本的左子树，因此使用终须遍历的话，会使原本的右子树根本没有被处理到。所以不推荐。如果一定要用，就把右子树递归处理里面的`root->right`改成`root->left`。
- 层序遍历看了视频，之后再遇到类似的题再补充层序遍历的笔记吧~ **层序遍历需要使用到队列这种数据结构*
- 迭代法就是非递归方式。编程语言里的递归本质上是使用**栈**这种数据结果，所以理论上，所有的递归都可以用栈模拟出来。但是一些复杂的递归，不必非用栈去模拟，不如直接用递归。
---
## 5. 复杂度分析

- 递归版本
	- 时间复杂度：**O(n)**，其中 `n` 是二叉树的节点数
		- 每个节点都会被访问一次，并进行左右子树的交换操作，所以时间复杂度是线性的
	- 空间复杂度：**O(h)**，其中 `h` 是树的高度
		- 递归调用的栈空间取决于树的最大深度。
		- 对于**平衡二叉树**，`h = O(log n)`，所以空间复杂度是 `O(log n)`
		- 对于**最坏情况（退化成链表）**，`h = O(n)`，空间复杂度是 `O(n)`
- 层序版本
	- 时间复杂度：**O(n)**
		- 每个节点被访问一次，并进行交换操作
	- 空间复杂度：**O(n)**
		- 对于**平衡二叉树**，队列的最大大小由最宽的一层决定，通常是 `O(n)` 的（如完全二叉树的最后一层）
		- 对于**最坏情况（退化成链表）**，队列的最大大小仍然是 `O(n)`（如单边树的情况）
---
## 6. 注意事项（可选）

- 目前先掌握到递归，然后大概了解了层序（没有笔记版）和迭代法（没有看完版），之后有遇到类似的题要学一学层序和迭代的哟