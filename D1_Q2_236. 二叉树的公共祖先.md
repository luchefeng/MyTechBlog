## 1. 题目描述及链接

[力扣题目链接(opens new window)](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  `root = [3,5,1,6,2,0,8,null,null,7,4]`

![236. 二叉树的最近公共祖先](https://file1.kamacoder.com/i/algo/20201016173414722.png)

示例 1: 输入: `root = [3,5,1,6,2,0,8,null,null,7,4]`, p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2: 输入: `root = [3,5,1,6,2,0,8,null,null,7,4]`, p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- `p`、`q` 为不同节点且均存在于给定的二叉树中。
---
## 2. 读完题以后的思路

- 自然想法是从下往上遍历，而树是递归往下，因此要配合回溯。而后序遍历是天然的回溯。
---
## 3. 代码实现
```cpp
class Solution{
public:
	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q){
	// 递归终止条件
	if (root == p || root == q || root == NULL) return root;
	// 左右子树递归
	TreeNode* left = lowestCommonAncestor(root->left, p, q);
	TreeNode* right = lowestCommonAncestor(root->right, p, q);
	// 处理后序遍历“左右中”的“中”
	if (left && right) return root;
	else if (left == NULL && right != NULL) return right;
	else if (left != NULL && right == NULL) return left;
	else //left == NULL && right == NULL
	return NULL;
	}
};
```
---
## 4. 细节说明

- 遍历二叉树的过程中，没法从下往上去遍历（因为是**递归**）。但是我们的处理顺序是可以从下往上去处理的（因为递归后可以有**回溯**，回溯可以做到）。想在回溯中得到这种从下往上的效果，需要配合**后序遍历**。回溯在这里体现为“左右中”的“中”。
- 代码虽然是按正常情况写的，但也已经包含了节点是它自己公共祖先的情况。
---
## 5. 复杂度分析

- ### **时间复杂度分析**

 **1. 最坏情况时间复杂度：O(N)**

- **原因**：算法会遍历树中的每个节点最多一次（通过后序遍历DFS）。
    
    - 每个节点的处理时间为常数时间 O(1)（仅进行指针比较和赋值）。
        
    - 对于具有 `N` 个节点的二叉树，总时间复杂度为 **O(N)**。
        
 **2. 最好情况时间复杂度：O(1)**

- **触发条件**：
    
    - `p` 或 `q` 直接等于 `root`（递归立即终止）。
        
    - 例如：`p` 是根节点，`q` 在其子树中，此时第一次递归就直接返回 `root`。
        
 **3. 平均时间复杂度：O(N)**

- 对于随机分布的树，仍需遍历大部分节点，因此平均时间复杂度仍为 **O(N)**。

- ### **空间复杂度分析**

 **1. 递归栈空间：O(H)**

- **H** 是树的高度，递归深度取决于树的结构：
    
    - **平衡二叉树**：`H = logN` → **O(logN)**。
        
    - **最坏情况（退化为链表）**：`H = N` → **O(N)**。
        
 **2. 额外空间：O(1)**

- 仅使用固定数量的指针变量（`left`, `right`），无额外数据结构。
    
 **总结空间复杂度**：

- **O(H)**（由递归栈主导，H为树高）。
---
## 6. 注意事项（可选）

1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。
    
2. 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
    
3. 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。