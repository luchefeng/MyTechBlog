## 1. 题目描述及链接

[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=problem-list-v2&envId=2cktkvj
给你两个单链表的头节点` headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![](https://file1.kamacoder.com/i/algo/20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例 1：

![](https://file1.kamacoder.com/i/algo/20211219221723.png)

示例 2：

![](https://file1.kamacoder.com/i/algo/20211219221749.png)

示例 3：

![](https://file1.kamacoder.com/i/algo/20211219221812.png)
---
## 2. 读完题以后的思路

- 首先，**该题想求两个单链表相交的起始节点，实际上说的是相求起始节点的指针**。需要注意的是，链表里的交点，不是指数值相等，而是指针相等（否则就成数组了）。
- 观察题目可以发现，两个链表在一般情况下，如果能有交点的话，都会在后半部分出现。因此**考虑 将两个链表的末尾进行对齐，然后将长链表从头指针一直往后遍历，直到和短链表此时的头指针对齐，就可以开始比较两个指针是否相同**。如果相同，返回指针，否则返回空指针。
---
## 3. 代码实现
```cpp
class Solution{
public:
	ListNode* getIntersectionNode(ListNode *headA, ListNode *headB){
	// 获取两个链表各自的头节点，准备遍历
	ListNode* curA = headA;
	ListNode* curB = headB;
	// 定义两个链表的长度，初始化为0
	int lenA = 0; int lenB = 0;
	// 获取链表A的长度
	while (curA != NULL){
		lenA++;
		curA = curA->next;
	}
	// 获取链表B的长度
	while (curB != NULL){
		lenB++;
		curB = curB->next;
	}
	// 让curA和curB重新指向两个链表的头部
	curA = headA;
	curB = headB;
	// 让curA成为最长链表的头部，lenA为其长度
	if (lenA < lenB){
		swap(lenA, lenB);
		swap(curA, curB);
	}
	// 求长度差
	int gap = lenA - lenB;
	// 在两个链表末尾对齐的情况下，将长链表遍历到和短链表头部对齐
	while (gap--){
		curA = curA->next;
	}
	// 遍历curA和curB，遇到相同直接返回
	while (curA != NULL){
		if (curA == curB)
			return curA;
		curA = curA->next;
		curB = curB->next;
	}
	// 否则返回空指针
	return NULL;
	}
};
```
---
## 4. 细节说明
- **该题想求两个单链表相交的起始节点，实际上说的是相求起始节点的指针**
- **考虑将两个链表的末尾进行对齐，然后将长链表从头指针一直往后遍历，直到和短链表此时的头指针对齐，就可以开始比较两个指针是否相同**。
---
## 5. 复杂度分析

-  **时间复杂度：O(n + m)**
- **空间复杂度：O(1)**

具体如下：
### 时间复杂度分析

1. **计算链表长度**：
    
    - `while (curA != NULL)`：遍历链表A → O(n)
        
    - `while (curB != NULL)`：遍历链表B → O(m)
        
    - 合计：O(n + m)
        
2. **对齐后同步遍历**：
    
    - `while (gap--)`：移动长链表指针 → 最多 O(|n-m|)
        
    - `while (curA != NULL)`：同步遍历 → 最多 O(min(n,m))
        
    - 合计：O(n + m)（因为 |n-m| + min(n,m) = max(n,m)）
        

**总时间复杂度**：O(n + m) + O(n + m) = **O(n + m)**

### 空间复杂度分析

- 只使用了固定数量的指针变量（`curA`, `curB`）和整型变量（`lenA`, `lenB`, `gap`）
    
- **没有使用递归、容器等额外存储**
    
- **总空间复杂度**：**O(1)**
---
## 6. 注意事项（可选）
- 关于`swap()`：
	- 在C++中，`swap` 是标准库提供的函数（需要 `<algorithm>` 或 `<utility>` 头文件）：
```cpp
#include <algorithm> // 或 #include <utility>
std::swap(a, b); // 直接交换a和b的值
```

- 如果是手动实现的 `swap`，通常这样写：
```cpp
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
```
- 时间复杂度：`O(1)`
    - 仅交换资源所有权（如指针）或基本数据，不复制实际数据。