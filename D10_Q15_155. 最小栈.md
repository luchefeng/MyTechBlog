## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/min-stack/?envType=problem-list-v2&envId=2cktkvj)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

**输入：**
`["MinStack","push","push","push","getMin","pop","top","getMin"]
`[[],[-2],[0],[-3],[],[],[],[]]`

**输出：**
`[null,null,null,null,-3,null,0,-2]`

**解释：**
`MinStack minStack = new MinStack();
`minStack.push(-2);
`minStack.push(0);
`minStack.push(-3);
`minStack.getMin();   --> 返回 -3.
`minStack.pop();
`minStack.top();      --> 返回 0.
`minStack.getMin();   --> 返回 -2.

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次
---
## 2. 读完题以后的思路

- 实现最小栈这个类
- 然后需要一个主栈和一个辅助栈，主栈记录所有元素，最小栈记录最小元素，要注意 更新
- `private`要自己写哦，还有构造函数不需要特别初始化。酷诶！
- 题目说了栈会是非空栈，所以可以不用考虑空栈情况了
---
## 3. 代码实现

```cpp
class MinStack{
private:
	std::stack<int> main_stack;
	std::stack<int> min_stack;
public:
	MinStack(){
		// 构造函数不需要特别初始化
	}

	void push(int val){
		main_stack.push(val);
		// 只在遇到新的最小值时才压入最小栈
		if (min_stack.empty() || val <= min_stack.top())
			min_stack.push(val);
	}

	void pop(){
		if (main_stack.top() == min_stack.top())
			min_stack.pop();
		main_stack.pop();
	}

	int top(){
		return main_stack.top();
	}

	int getMin(){
		return min_stack.top();
	}
};
```
---
## 4. 细节说明

- `push()`那里注意，只在遇到新的最小值时才压入最小栈。这样比较节省栈空间，不过相应的，之后的`pop()`就不能无脑弹出了，对于辅助栈，得判断一下。
- 力扣给的官方题解在`push()`那里就是每次都会更新辅助栈，哪怕会重复更新，所以它的`pop()`就是无脑弹出的
---
## 5. 复杂度分析

- 时间复杂度：`O(1)`
	- 因为只操作栈顶元素的入栈和出栈
- 空间复杂度：`O(n)`
	- 因为栈内最坏可能把所有元素存进去
---
## 6. 注意事项（可选）
