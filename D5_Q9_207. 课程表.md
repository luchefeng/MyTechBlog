## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/course-schedule/description/?envType=problem-list-v2&envId=2cktkvj)
你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

**输入：**`numCourses = 2, prerequisites = [[1,0]]`
**输出：**`true`
**解释：**总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

**示例 2：**

**输入：**`numCourses = 2, prerequisites = [[1,0],[0,1]]`
**输出：**`false`
**解释：**总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**
---
## 2. 读完题以后的思路

- 特别熟悉的场景，必是图论。然后我就去看到底是图论的哪一个内容。找到了：拓扑排序！
#### 拓扑排序`BFS`思路
拓扑排序过程，其实就两步：
- **第一步，找到入度为`0`的节点，加入结果集**
- **第二步，将该节点从图中移除**
- 循环以上两步，直到所有节点都在图中被移除了。结果集的顺序，就是我们想要的拓扑排序顺序（结果集里顺序可能不唯一）
- **如果我们发现结果集元素个数 不等于 图中节点个数，就可以认定图中一定有 有向环**
---
## 3. 代码实现

```cpp
class Solution{
public:
	bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
		vector<int> result; // 结果集
		vector<int> inDegree(numCourses, 0); // 每个节点的入度情况
		vector<vector<int>> adj(numCourses); // 邻接表，记录文件的依赖关系

		// 构建文件依赖关系
		for (int i = 0; i < prerequisites.size(); i++){
			int from = prerequisites[i][1];
			int to = prerequisites[i][0];
			adj[from].push_back(to);
			inDegree[to]++;
		}

		// 记录初始情况下，入度为0的节点
		queue<int> que;
		for (int i = 0; i < numCourses; i++){
			if (inDegree[i] == 0) que.push(i);
		}

		// 找到入度为0的节点并放入结果集
		while (!que.empty()){
			int cur = que.front(); que.pop();
			result.push_back(cur);
			// 将节点从图中移除
			vector<int> files = adj[cur]; // cur指向的所有文件
			if (files.size()){
				for (int i = 0; i < files.size(); i++){
					inDegree[files[i]]--;
					if (inDegree[files[i]] == 0) que.push(files[i]);
				}
			}
		}
		// 判断结果集里含有的节点的数目是否等于总节点数
		return result.size() == numCourses;
	}
};
```
---
## 4. 细节说明

- 用到的数据结构：
	- 一维数组`vector`
		- 用于记录每个文件的入度 以及 用于记录结果
	- 无序映射`unordered_map`
		- 用于记录文件的依赖关系
	- 队列`queue`
		- 用于存放入度为`0`的节点
- **对“移除节点”的理解**
	- 为什么要把节点从图中移除？
		- 为的是将 该节点作为出发点所连接的边删掉
			- 删掉的目的是什么呢？
				- 要把该节点作为出发点所连接的节点的入度 减一
	- 所以，在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉
- 对于本题的话，和随想录里不同的是，这里它给定了一个数组`prerequisites`，而且不需要自己描述输入，所以这题在存依赖关系这一步，需要自己构建邻接表。这也是我卡住没通过的原因。
- 这个邻接表的构建，经典答案会用范围`for`循环，但是这个我自己写不出来，所以我偏向于用普通`for`循环。
---
## 5. 复杂度分析

### **时间复杂度**`O(V + E)`

1. **构建邻接表和入度数组**：
    - 遍历 `prerequisites` 数组，其长度为 `E`（边的数量）。
    - 每个 `prerequisites[i]` 的处理是 `O(1)`（访问数组 + 修改 `adj` 和 `inDegree`）。
    - **时间复杂度**：`O(E)`。
2. **初始化队列（入度为 0 的节点）**：
    - 遍历所有 `numCourses`（`V` 个节点），检查 `inDegree[i] == 0`。
    - **时间复杂度**：`O(V)`。
3. **拓扑排序（BFS 部分）**：
    - 每个节点最多入队一次、出队一次，共 `V` 次操作，每次 `O(1)`。
    - 遍历所有邻接边（即所有 `prerequisites` 的边），共 `E` 次操作。
    - **时间复杂度**：`O(V + E)`。
4. **最终结果比较**：
    - `result.size() == numCourses` 是 `O(1)` 操作。
✅ **总时间复杂度**：`O(V + E)`，其中 `V = numCourses`，`E = prerequisites.size()`。

### **空间复杂度****`O(V + E)`

1. **`inDegree` 数组**：
    - 存储每个节点的入度，`O(V)`。
2. **`adj` 邻接表**：
    - 存储所有边，最坏情况（完全图）需要 `O(V + E)` 空间。
3. **`result` 数组**：
    - 存储拓扑排序结果，`O(V)`。
4. **`que` 队列**：
    - 最多存储所有节点（无环时），`O(V)`。
✅ **总空间复杂度**：`O(V + E)`。

---
## 6. 注意事项（可选）

### 拓扑排序

- 是什么：
	- **给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序**。
	- 拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。**所以拓扑排序也是图论中判断有向无环图的常用方法。**
	- 拓扑排序指的是 一种解决问题的大体思路，而具体算法，可能是广搜也可能是深搜。**一般掌握卡恩算法`(BFS)`就可以了。**
- 理解重点：
	- 做拓扑排序的时候，应该优先找 入度为0的节点，只有入度为0，它才是出发节点