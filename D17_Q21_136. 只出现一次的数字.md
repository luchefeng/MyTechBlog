## 1. 题目描述及链接
[力扣描述](https://leetcode.cn/problems/single-number/?envType=problem-list-v2&envId=2cktkvj)
给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

**输入：**nums = [2,2,1]

**输出：**1

**示例 2 ：**

**输入：**nums = [4,1,2,1,2]

**输出：**4

**示例 3 ：**

**输入：**nums = [1]

**输出：**1

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。
---
## 2. 读完题以后的思路
- **我读完题想的就是用哈希表。但是又把这个过程想一遍以后，发现哈希表不满足空间复杂度为`O(1)`，所以我就卡壳了。**
-  谁能知道**这题要用位运算之异或**呢？力扣官方知道！我是做梦都想不到的。
- **如果题目不规定复杂度，那还可以考虑使用集合。**
	- **第一种办法，遍历数组，如果集合中没有该元素，就把它放进集合；要是集合中已经有了，就把这元素从集合中删了。最后留在集合里的就是所求元素。
	
	- **第二种办法，遍历数组，把所有元素放进集合，然后用两倍集合里的元素之和`-`数组元素之和，就是要求的元素。**
---
## 3. 代码实现

### 简练一点的版本
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int num : nums){
            result ^= num;
        }
        return result;
    }
};
```
### 我的版本
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = nums[0];
        for (int i = 1; i < nums.size(); i++){
            result ^= nums[i];
        }
        return result;
    }
};
```
---
## 4. 细节说明

- 短短几行代码，我可把所有坑都踩了
- 第一，我测试了一下，是可以把`result`初始化为`nums[0]`的，然后后续计数器`i`从`1`开始就行
- 第二，**如果用上面那种范围`for`循环，那要记得，那个`num`不像普通`for`循环那样是下标，它就是里面的数本身**，就不要写出`nums[num]`这种表达了哈。
---
## 5. 复杂度分析

- 时间复杂度：`O(n)`
	- 因为就把整个数组遍历完了
- 空间复杂度：`O(1)`
	- 用了一个变量存每一次的异或结果
---
## 6. 注意事项（可选）

### 关于异或，你该知道的都在这里！

异或运算有以下特点：
1. **任何数和 0 异或，结果仍然是原来的数**：`a ^ 0 = a`
2. **任何数和自身异或，结果是 0**：`a ^ a = 0`
3. **异或运算满足交换律和结合律**：`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`
因此，如果我们对整个数组中的所有元素依次进行异或运算，出现两次的元素会互相抵消（因为 `a ^ a = 0`），最后剩下的就是只出现一次的元素（因为 `a ^ 0 = a`）。