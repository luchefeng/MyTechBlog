## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/lru-cache/description/?envType=problem-list-v2&envId=2cktkvj)
请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

**输入**
`["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]`
`[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]`
**输出**
`[null, null, null, 1, null, -1, null, -1, 3, 4]`

**解释**
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`
---
## 2. 读完题以后的思路

- 明确了是实现一种数据结构，以适应`LRU`算法
- **考虑到`LRU`本身的理论实现，我会想到使用双端的数据结构，比如双端队列或者双向链表**。由于`get()`操作中，当一个页被访问后，它会被更新到头部，而双端队列相对来说还是有一种“`FIFO`的感觉，时间复杂度能达到`O(n)`，而**双向链表的话，移动节点只需要改变指针的指向就可以了，因此时间复杂度是`O(1)`。考虑到题目对时间复杂度的要求，我会选择双向链表。**
- 然后是关于查找，题目本身提到键值对，还有时间复杂度为`O(1)`的查找，我就会想到哈希映射`unordered_map`。
- 综上，选择**双向链表+哈希映射**来完成这个数据结构的设计
- 注意，从题目提示来看，是需要用到`new/delete`的
---
## 3. 代码实现

```cpp
 struct DLinkedNode{
    int key; int value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache{
private:
    unordered_map<int, DLinkedNode*> cache;// 哈希表，key为待查数据的key，value为待查数据在双向链表中的位置
    DLinkedNode* head; // 双向链表的哑头节点
    DLinkedNode* tail; // 双向链表的哑尾节点
    int size; // 当前大小
    int capacity; // 总的LRU大小
    
public:
    LRUCache(int _capacity): capacity(_capacity), size(0){
        // 使用哑头部和哑尾部
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key){
        // 没找到返回-1
        if (!cache.count(key)){
            return -1;
        }

        // 如果key存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value){
        if (!cache.count(key)){
            // 如果key不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity){
                 // 如果超出容量，删除双向链表的尾部节点
                 DLinkedNode* removed = removeTail();
                 // 删除哈希表中对应的项
                 cache.erase(removed->key);
                 // 防止内存泄漏
                 delete removed;
                 --size;
            }
        }
        else{
            // 如果key存在，先通过哈希表定位，再修改value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node){
        node->prev = head; // node向两边
        node->next = head->next;
        node->next->prev = node; // 两边向node
        head->next = node;
    }

    void removeNode(DLinkedNode* node){
        node->prev->next = node->next;// 双向链表要前后分别建立联系
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node){
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail(){
        DLinkedNode* node = tail->prev; // 尾部节点是tail的前一个节点
        removeNode(node); // 调用通用的removeNode函数
        return node; // 返回被移除的节点，供外部删除
    }
};
```
---
## 4. 细节说明

- 双向链表里存什么：存题目要求的键值对，以及节点本身会有的前后指针
- 哈希映射里存什么：`key`存待查数据的`key`，`value`存待查数据在双向链表中的位置
- `unordered_map`本身如果要删除的话。使用`erase()`
- 注意初始化函数的写法，都很细节
- 记得要`new/delete`配合用，避免内存泄漏
---
## 5. 复杂度分析

- 时间复杂度：`O(1)`
	- 双向链表的插入和删除都是`O(1)`，而查找使用了哈希表，所以是`O(1)`
- 空间复杂度：`O(n)`
	- 因为使用了哈希表和双向链表，最多存`capacity`个数
---
## 6. 注意事项（可选）

- 这种设计数据结构的题，非常考验基本功。因此要小心一些