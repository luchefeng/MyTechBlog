## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/number-of-islands/description/?envType=problem-list-v2&envId=2cktkvj)
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

**输入：**grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
**输出：**1

**示例 2：**

**输入：**grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
**输出：**3

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`
---
## 2. 读完题以后的思路

- 和图有关，尤其是四个方向图的搜索。然后就看视频去了。
- 看完视频，发现思路是：
	- **遍历图，如果是海洋就跳过，如果是陆地就将岛屿数量加一，并使用搜索算法（深搜广搜都可以）将与其相连的陆地都标记为访问过**
	- 关键：使用搜索算法（深搜广搜都可以）将与其相连的陆地都标记为访问过）。
	- 使用深搜（递归）避免无限递归的关键：将访问过的节点做标记，并且不访问已经标记的节点
	- 
---
## 3. 代码实现

### 以下是深搜版本（隐式递归条件）
```cpp
class Solution {

public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int result = 0;
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        // 遍历全图，寻找新陆地
        for (int i = 0; i < n; i++){
            for (int j = 0; j <m; j++){
                if (grid[i][j] == '1' && !visited[i][j]){ // 如果找到新陆地
                    result++; // 岛屿数量加一
                    visited[i][j] = true; // 立马标记为访问过
                    dfs(grid, visited, i, j); // 深搜访问与该陆地相连的所有陆地
                }
            }
        }
        return result;
    }

	// 深搜
    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1}; // 上下左右四个方向
    void dfs(vector<vector<char>> & grid, vector<vector<bool>> & visited, int x, int y){
        for (int i = 0; i < 4; i++){
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue; // 越界直接跳过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1'){
                visited[nextx][nexty] = true;
                dfs(grid, visited, nextx, nexty);
            }
        }
    }
};
```

### 以下是深搜版本（显式递归条件）
```cpp
class Solution {

public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int result = 0;
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        // 遍历全图，寻找新陆地
        for (int i = 0; i < n; i++){
            for (int j = 0; j <m; j++){
                if (grid[i][j] == '1' && !visited[i][j]){ // 如果找到新陆地
                    result++; // 岛屿数量加一
                    // 这句在深搜版本（显式递归条件）里不能要：visited[i][j] = true; // 立马标记为访问过
                    dfs(grid, visited, i, j); // 深搜访问与该陆地相连的所有陆地
                }
            }
        }
        return result;
    }

	int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1}; // 上下左右四个方向
    void dfs(vector<vector<char>> & grid, vector<vector<bool>> & visited, int x, int y){
        if (grid[x][y] == '0' || visited[x][y]) return; // 终止条件：遇见海洋或已经被访问过
        visited[x][y] = true;
        for (int i = 0; i < 4; i++){
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue;
            dfs(grid, visited, nextx, nexty);
        }
    }
};
```

### 以下是广搜版本

```cpp
// 广搜版本

class Solution {

public:

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, 0));
        int result = 0;
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++){
                if (!visited[i][j] && grid[i][j] == '1'){
                    result++; // 遇到没访问过的陆地，+1
                    bfs(grid, visited, i, j); // 将与其连接的陆地都标记上 true
                }
            }
        }
        return result;
    }

    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
    void bfs(vector<vector<char>> & grid, vector<vector<bool>> & visited, int x, int y){
        queue <pair<int, int>> que;
        que.push({x, y});
        visited[x][y] = true; // 一入队列立马标记
        while (!que.empty()){
            pair<int, int> cur = que.front(); que.pop();
            int curx = cur.first;
            int cury = cur.second;
            for (int i = 0; i < 4;i++){
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                    continue;
                if (!visited[nextx][nexty] && grid[nextx][nexty] == '1'){
                    que.push({nextx, nexty});
                    visited[nextx][nexty] = true;
                }
            }
        }
    }
};
```
---
## 4. 细节说明

- 我觉得需要注意的一点就是，**这个题它的陆地和海洋用的是字符`'1'`和`'0'`，所以图`grid`定义的时候要注意写成二维的`char`类型的数组。**
- 注意**立马标记访问**，很容易忘记的
- **深搜版本（显式递归条件）在主函数（就是力扣默认给的那个函数）里面就不需要再标记`visited[i][j] = true`了**，因为`dfs`比主函数晚一点，所以虽然`dfs`里标记了`visited`，但是主函数那时还不知道，就会按自己的顺序去继续标记，也就是`dfs`白干，那么就**会使得一个陆地与其连通的陆地并不被及时标记，就会被记成新岛屿，导致计数错误**
- 广搜`que.push()`那里，因为入队的是一个`pair<int, int>`类型，所以`que.push()`的括号里的那组参数，得用花括号`{}`括起来哟
- 记得`int result = 0;`，要把它初始化哦，不然结果很随机！
---
## 5. 复杂度分析

### 深搜的复杂度分析
#### **1. 时间复杂度：O(M×N)**
- **每个网格节点最多被访问 1 次**（通过 `visited` 数组避免重复访问）。
- **主循环遍历所有节点**：`for (i=0→n), for (j=0→m)` → O(M×N)。
- **DFS/BFS 访问所有连通陆地**：每个 `'1'` 只会被处理一次，因此 **整体时间复杂度是 O(M×N)**。
#### **2. 空间复杂度：O(M×N)**
- **`visited` 数组**：存储每个节点是否被访问过 → O(M×N)。
- **递归栈（DFS）**：
    - 最坏情况下（整个网格全是 `'1'`），递归深度为 O(M×N)（比如一条斜线状的岛屿）。
    - 但通常情况下，递归深度由岛屿的最大面积决定，平均可视为 O(min(M,N))。
- **优化方向**：
    - 如果允许修改原矩阵，可以直接把访问过的 `'1'` 改成 `'0'`，省去 `visited` 数组 → **空间复杂度降至 O(1)**（但递归栈空间不变）。
---
### 广搜的复杂度分析

#### **1. 时间复杂度：O(M×N)**
- **每个网格节点最多被访问一次**：
    - 主循环 `for (i=0→n), for (j=0→m)` 遍历所有节点 → O(M×N)。
    - BFS 访问连通陆地时，每个 `'1'` 仅入队一次，且每次入队后会被标记为已访问（`visited[nextx][nexty] = true`），**无重复计算**。
- **综合**：所有操作均摊到每个节点后，总时间为 **O(M×N)**。
#### **2. 空间复杂度：O(M×N)**
- **`visited` 数组**：存储每个节点的访问状态 → O(M×N)。
- **队列 `que` 的空间**：
    - 最坏情况下（整个网格全是 `'1'`），队列会存储所有陆地节点 → O(M×N)。
    - 实际运行时，队列大小取决于当前处理的岛屿面积，通常远小于 M×N。
- **优化方向**：
    - 若允许修改原矩阵，可将访问过的 `'1'` 直接改为 `'0'`，省去 `visited` 数组 → **空间复杂度降至 O(min(M,N))**（队列的峰值空间）。
---
## 6. 注意事项（可选）

- 深搜实现体现在递归
- 广搜实现体现在队列
