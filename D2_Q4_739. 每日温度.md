## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/daily-temperatures/description/?envType=problem-list-v2&envId=2cktkvj)
给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

**输入:** `temperatures` = [73,74,75,71,69,72,76,73]
**输出:** [1,1,4,2,1,1,0,0]

**示例 2:**

**输入:** temperatures = [30,40,50,60]
**输出:** [1,1,1,0]

**示例 3:**

**输入:** temperatures = [30,60,90]
**输出:** [1,1,0]

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`
---
## 2. 读完题以后的思路

- 经典单调栈的题目。但是具体怎么用我给忘了。
- 看完视频后的思路总结：
	- 建立单调栈
	- 第一个元素下标入栈。然后开始遍历数组，讨论当前遍历元素和栈顶元素的三种情况：`>` `<` 
	- 返回结果
---
## 3. 代码实现

```cpp
class Solution {

public:

    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st; // 单调增栈
        st.push(0); // 第一个元素的下标入栈
        vector<int> result(temperatures.size(), 0); // 记录结果的数组，下标是栈顶元素的下标
        for (int i = 1; i < temperatures.size(); i++){// 遍历整数数组
            // 情况一：当前遍历到的元素小于栈顶元素
            // 情况二：当前遍历到的元素等于栈顶元素
            // 都直接将它们入栈，暂候
            if (temperatures[i] <= temperatures[st.top()])
                st.push(i);
            else{// 情况三，当前遍历到的元素大于栈顶元素，开始处理结果
                    // 注意，因为涉及弹出操作，要判断栈空
                while (!st.empty() && temperatures[i] > temperatures[st.top()]){
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                // 当前元素不再比栈顶元素大的时候，当前元素入栈
                st.push(i);
            }
        }
        return result;
    }
};
```
---
## 4. 细节说明

- 结果数组`result`里的下标是栈顶元素的下标，值是`当前遍历元素的下标`-`栈顶元素的下标`，即距离。此外，它的初始化很重要，因为最后如果有元素它没有找到第一个更大元素，就会留在栈里，而因为我们初始化的时候就初始成了题目认可的`0`，所以可以让它们继续留在栈里
- 判断当前元素和栈顶元素的情况时，要用`while`持续比较；而且因为涉及弹出操作，要注意判断栈空

---
## 5. 复杂度分析

- #### 时间复杂度：`O(N)`
	- 每个元素最多被压入栈一次、弹出栈一次（均摊分析），虽然存在嵌套的 `while` 循环，但所有元素的弹出操作总和不超过 `n` 次
- #### 空间复杂度:`O(N)`
	- 单调栈在最坏情况下可能存储全部 `n` 个元素
- #### 补充一个复杂度排序
	- ##### **时间复杂度由低到高排序**（空间复杂度顺序也是这个）

| 复杂度表示          | 中文名称      | 英文名称              | 典型算法示例      | 直观增长趋势       |
| -------------- | --------- | ----------------- | ----------- | ------------ |
| **O(1)**       | 常数时间复杂度   | Constant time     | 数组随机访问      | 无增长          |
| **O(log n)**   | 对数时间复杂度   | Logarithmic time  | 二分查找        | 极缓慢增长（几乎水平线） |
| **O(n)**       | 线性时间复杂度   | Linear time       | 遍历数组        | 直线增长         |
| **O(n log n)** | 线性对数时间复杂度 | Linearithmic time | 快速排序、归并排序   | 接近线性但略快      |
| **O(n²)**      | 平方时间复杂度   | Quadratic time    | 冒泡排序、简单选择排序 | 抛物线增长        |
| **O(2ⁿ)**      | 指数时间复杂度   | Exponential time  | 暴力穷举（如子集枚举） | 爆炸式垂直增长      |
| **O(n!)**      | 阶乘时间复杂度   | Factorial time    | 如旅行商问题）     | 超指数级增长（最陡峭）  |

---
## 6. 注意事项（可选）

- #### 关于单调栈：
	- 什么是单调栈：
		- 从栈里弹出来的元素是单调的
		- 也可以理解为**从栈顶到栈底**递增就是单调增，递减就是单调减
	- 单调栈解决什么问题：
		- 找一个元素**左面`or`右面**第**一**个比它**大`or`小**的元素
	- 单调栈里存什么
		- 存元素的索引下标，原因有三：
			- 唯一的索引可以找到唯一的值（而在元素重复的情况下，同一个值可能有不同的索引，即没法保证唯一）
			- 可以通过索引找元素，很方便（如果存元素的话，就要回去找索引，没有根据索引找元素方便）
			- 根据下标计算待求差值也很方便
	- 本题单调栈作用：
		- 用于记录已经 遍历了但还没找到下一个更大元素 的元素
	
	