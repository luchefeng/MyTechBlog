## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/reverse-linked-list/description/?envType=problem-list-v2&envId=2cktkvj)
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

**输入：**head = [1,2,3,4,5]
**输出：**[5,4,3,2,1]

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

**输入：**head = [1,2]
**输出：**[2,1]

**示例 3：**

**输入：**head = []
**输出：**[]

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`
**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
---
## 2. 读完题以后的思路

- 链表是通过指针串在一起的，所以要反转链表，就是要反转指针的指向。
- 这个题和`D2_Q3_234.回文链表`这个题里面那个反转链表部分一样的。
- 递归法是看到“进阶”才发现的，看的随想录视频
---
## 3. 代码实现

### 双指针法（迭代法）
```cpp
// 双指针解法
class Solution{
public:
	ListNode* reverseList(ListNode* head) {
		ListNode* prev = NULL;
		ListNode* cur = head;
		while (cur != NULL){
			ListNode* temp = cur->next;
			cur->next = prev;
			prev = cur;
			cur = temp;
		}
		return prev;
	}
};
```

### 递归
```cpp
// 递归解法
class Solution{
public:
	ListNode* reverseList(ListNode* head){
		return reverse(head, NULL);
	}
	ListNode* reverse(ListNode* cur, ListNode* prev){
		// 递归终止条件
		if (cur == NULL) return prev;
		ListNode* temp = cur->next;
		cur->next = prev;
		return reverse(temp, cur);
	}
};
```
---
## 4. 细节说明

- 要理解交换过程，为此我特地请教`DeepSeek`，让它演示一下，关键点是这样的：
1. **`prev`**：始终指向已反转部分的头节点。
2. **`cur`**：指向待反转的当前节点。
3. **`temp`**：临时保存 `cur->next`，防止链表断裂。
4. **核心操作**：
    - 反转箭头：`cur->next = prev`。
    - 移动指针：`prev` 和 `cur` 后移。
- 关于递归的写法：
	- **我看的[随想录网站](https://www.bilibili.com/video/BV1nB4y1i7eL?t=5.8)，可以跟着双指针法的思路来实现。注意递归函数要`return`一下哈**
---
## 5. 复杂度分析
### 双指针法（迭代法）
- 时间复杂度：``O(N)`
	- 因为遍历了整个链表，但是进行的是简单的交换操作
- 空间复杂度：`O(1)`
	- 因为在原链表上改的，没有额外空间
### 递归
- 时间复杂度：``O(N)`
	- 因为遍历了整个链表，但是进行的是简单的交换操作
- 空间复杂度：`O(n)`
	- 因为递归栈最多占`n`个元素的空间大小
---
## 6. 注意事项（可选）

### **1. 迭代法（双指针法）**

**核心思想**：用三个指针（`prev`、`cur`、`temp`）逐步反转箭头。  
**时间复杂度**：O(n)  
**空间复杂度**：O(1)

### **2. 递归法**

**核心思想**：递归到链表末尾，从后向前反转箭头。  
**时间复杂度**：O(n)  
**空间复杂度**：O(n)（递归栈空间）
