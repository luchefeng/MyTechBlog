## 1. 题目描述及链接

[力扣链接](https://leetcode.cn/problems/maximum-product-subarray/?envType=problem-list-v2&envId=2cktkvj)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

**输入:** `nums = [2,3,-2,4]`
**输出:** `6`
**解释:** 子数组 [2,3] 有最大乘积 6。

**示例 2:**

**输入:** `nums = [-2,0,-1]`
**输出:** 0
**解释:** 结果不能为 2, 因为 [-2,-1] 不是子数组。

**提示:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数
---
## 2. 读完题以后的思路

- 暴力思路就是遍历整个数组，找出每一个可能的连续子数组，计算乘积，最后找出最大值。这个时间复杂度就是`O(n^3)`了，很高
- 感觉会有什么技巧，但是不知道是什么技巧。现在知道了，是动态规划
- 看完题解，我估计就是“最大子数组和”那个题的变式了。下面用动规五部曲解决：
### 动规五部曲
- 第一步，`dp`数组及其含义：由于这里是求乘积，因此需要考虑当前的数`nums[i]`的正负，正数的话，希望前面的乘积更大，因为正数乘正数更大；负数的话，希望前面的乘积更小，因为负数乘负数最大。所以需要两个`dp`数组，即`dp_max`:以下标`i`为结尾的连续子数组的最大乘积，`dp_min`:以下标`i`为结尾的连续子数组的最小乘积。
- 第二步，递推公式。
	- 当`nums[i]`正数： `dp_max[i] = max(nums[i], nums[i] * dp_max[i-1]);`
					 `dp_min[i] = min(nums[i], nums[i] * dp_min[i-1]);`
	 - 当`nums[i]`负数： `dp_max[i] = max(nums[i], nums[i] * dp_min[i-1]);`
					 `dp_min[i] = min(nums[i], nums[i] * dp_max[i-1]);`
- 第三步，初始化。这里需要注意，因为连续子数组的最大乘积可能会在中间的子数组中就出现，不一定非在最后一个元素处才出现，因此还需要一个全局的变量`max_product`来记录真正的结果。然后由递推公式倒推，知最起始的应该是`dp[0]`，所以有`dp_max[0] = nums[0]; dp_min[0] = nums[0]; int max_product = nums[0];
- 第四步，遍历顺序。很自然了，从前往后。不过注意计数器`i`从`1`开始哦
- 第五步，打印`dp`数组
---
## 3. 代码实现

```cpp
class Solution {

public:

    int maxProduct(vector<int>& nums) {
        // 边界条件： (不过实际上由题意，数组不会为空的)

        // dp_max 数组含义：以i结尾的，连续子数组的 最大乘积
        // dp_min 数组含义：以i结尾的，连续子数组的 最小乘积
        int n = nums.size();
        vector<int> dp_max(n+1, 0);
        vector<int> dp_min(n+1, 0);
        // 初始化
        dp_max[0] = nums[0];
        dp_min[0] = nums[0];
        int max_product = nums[0];
        // 遍历顺序及递推公式
        for (int i = 1; i < n; i++)
            if (nums[i] > 0){
                dp_max[i] = max(nums[i], nums[i] * dp_max[i-1]);
                dp_min[i] = min(nums[i], nums[i] * dp_min[i-1]);
            }
            else{
                dp_max[i] = max(nums[i], nums[i] * dp_min[i-1]);
                dp_min[i] = min(nums[i], nums[i] * dp_max[i-1]);
            }
            max_product = max(dp_max[i], max_product); // 更新全局最大的乘积
        }
        return max_product;
    }
};
```
---
## 4. 细节说明

- 本来一开始还应该考虑一下边界情况，即给定的数组是否为空。不过由题意，因为题目说了，子数组一定至少一个元素，所以这个数组肯定不为空，我就没考虑了
- 对于`nums[i]`为`0`的情况，我直接包含在`else`里面了，其实它放在“正数”或者“负数”的范畴里都可以
---
## 5. 复杂度分析

- 时间复杂度：`O(N)`
	- 因为遍历了整个数组，做了找最值的操作，没有嵌套操作
- 空间复杂度：`O(N)`
	- 使用了两个`O(N)`复杂度的数组，和一个`O(1)`的常数级变量
---
## 6. 注意事项（可选）
